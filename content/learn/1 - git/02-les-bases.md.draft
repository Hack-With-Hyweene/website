---
id: 2
title: Les bases de Git
summary: Introduction aux concepts fondamentaux de Git, y compris les commandes de base, la gestion des branches, et le travail avec des repositories distants.
tags: git, système de contrôle de version, contrôle, version, versionning, vcs, git basics, git commands, branches, merging, remote repositories

publish_date: 2025-10-13T09:30:00+01:00

prism_needed: true
---

## Commandes de base

### git init et git clone

#### git init

Initialise un nouveau dépôt Git.

Quand on execute `git init` dans un dossier, Git crée un sous-dossier `.git` qui contient tous les fichiers nécessaires au dépôt. Par défaut, le repo git nouvellement créé n'a pas de branche principale (main ou master). Vous pouvez commencer à ajouter des fichiers et faire des commits.

Il faudra penser à configurer une origine distante (remote) si vous souhaitez pousser vos changements vers un serveur distant plus tard.

#### git clone

Clone un dépôt existant.

Pour cloner un dépôt existant, utilisez la commande `git clone` suivie de l'URL du dépôt. Par exemple :

```bash
git clone https://github.com/username/repo.git
```

Cette commande crée une copie locale du dépôt distant, y compris tout son historique de versions.

### git add et staging area

`git add` : Ajoute des fichiers à la staging area (zone de préparation).

Dans le détail : Quand on modifie des fichiers dans le working directory, ces modifications ne sont pas inclues dans le prochain commit tant qu'on ne les a pas staged.

La staging area est une zone intermédiaire où vous pouvez préparer les modifications que vous souhaitez inclure dans le prochain commit. Vous pouvez ajouter des fichiers spécifiques ou tous les fichiers modifiés.

Par exemple, pour ajouter un fichier spécifique :

```bash
git add fichier.txt
```

Pour ajouter tous les fichiers modifiés, même les nouveaux fichiers non suivis :

```bash
git add .
```

Ou alors, si vous voulez ajouter les changements qui sont faits sur des fichiers déjà suivis par git, vous pouvez utiliser :

```bash
git add -u
```

### gitignore

- `.gitignore` : Fichier pour ignorer des fichiers ou des dossiers dans un dépôt Git.

Le fichier `.gitignore` permet de spécifier des fichiers ou des dossiers que Git doit ignorer. Cela est particulièrement utile pour ne pas inclure des fichiers temporaires, des fichiers de configuration locaux, ou d'autres fichiers que vous ne souhaitez pas suivre.

Par exemple, pour ignorer tous les fichiers `.log` et le dossier `node_modules` et éviter d'uploader internet dans votre repo git, vous pouvez créer un fichier `.gitignore` avec le contenu suivant :

```
*.log
node_modules/
```
#### Nb1 : Override d'une règle dans .gitignore

Si vous souhaitez forcer le suivi d'un fichier ou d'un dossier qui correspond à une règle dans `.gitignore`, vous pouvez utiliser le caractère `!` pour annuler la règle. Par exemple, si vous voulez ignorer tous les fichiers `.log` sauf `important.log`, vous pouvez écrire dans `.gitignore` :

```
*.log
!important.log
```

#### Nb2 : Fichier à ignorer déjà suivi

Si un fichier est déjà suivi par Git, l'ajouter à `.gitignore` ne le supprimera pas du suivi. Vous devrez d'abord le supprimer du suivi avec `git rm --cached nom_du_fichier`.

### git status, git log, et git diff

#### git status

Affiche l'état actuel du dépôt.

Git status montre les fichiers modifiés, ceux qui sont en staging, et ceux qui ne sont pas suivis. C'est une commande très utile pour voir où vous en êtes dans votre flux de travail.

Dans le détail, `git status` affiche :

- Les fichiers dans la staging area prêts à être commités.
- Les fichiers modifiés mais pas encore ajoutés à la staging area.
- Les fichiers non suivis (untracked files).

#### git log

Affiche l'historique des commits.

Git log montre une liste des commits précédents, avec des informations telles que l'ID du commit, l'auteur, la date, et le message de commit. Vous pouvez utiliser diverses options pour formater la sortie.

Exemple, si je veux voir un log plus compact et visuel, je peux utiliser : 

```bash
git log --oneline --graph --decorate
```

Si j'execute cette commande, dans mon dossier dotfiles, j'obtiens : 

```bash
bgiarrizzo@cloe:~/code/dotfiles$ git log --oneline --graph --decorate 
* 0a5ebf6 (HEAD -> master, origin/master, origin/HEAD)  update readme
* cf2462d update git config
* 570aa21 update zshrc
* 34e5961 update credentials
* e5f419f update weechat
* 39380fb add newsboat
* d0e7b82 update mutt config

[...]
```

On peut voir ici les différents commits, avec leurs IDs, messages, et la branche courante (HEAD).

#### git diff

Affiche les différences entre les fichiers.

Prenons par exemple le fichier `README.md` du repo de mon site.

```bash
cat README.md
# Hack with Hyweene
```

Si je modifie ce fichier pour ajouter une ligne, et que j'execute `git diff`, j'obtiens : 

```bash
(website-hackwithhyweene) bgiarrizzo@cloe:~/code/website-hackwithhyweene$ git diff README.md
diff --git a/README.md b/README.md
index dc9590a..3a961d4 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,3 @@
 # Hack With Hyweene
+
+Bonjour !
```

Cela montre les différences entre la version actuelle du fichier et la dernière version commitée. Les lignes supprimées sont précédées d'un `-` et les lignes ajoutées d'un `+`.

On voit ici que j'ai ajouté deux lignes, une ligne vide et une ligne avec "Bonjour !".

### git commit et bonnes pratiques pour les messages de commit

- `git commit` : Enregistre les modifications dans l'historique du dépôt.

Comme vu précédement, après avoir ajouté des fichiers à la staging area avec `git add`, vous pouvez enregistrer ces modifications dans l'historique du dépôt avec `git commit`.

Par exemple, pour faire un commit avec un message descriptif :

```bash
git commit -m "Message de commit descriptif"
```

Il est important d'écrire des messages de commit clairs et descriptifs pour faciliter la compréhension de l'historique du projet. 

Voici quelques bonnes pratiques pour rédiger des messages de commit efficaces : 

- Utiliser l'impératif (ex : "Ajouter la fonctionnalité X" au lieu de "Ajouté la fonctionnalité X" ou "Ajoute la fonctionnalité X").
- Être concis mais informatif (idéalement moins de 50 caractères).
- Fournir plus de détails dans le corps du message si nécessaire (séparé du titre par une ligne vide).

#### Exemple de message de commit avec corps :

##### Classique : 

```
Ajouter la fonctionnalité X
- Implémente la fonctionnalité X avec les tests associés.
- Corrige le bug Y lié à la fonctionnalité Z.
```

##### Avec des emojis (optionnel) :

```
✨ Ajouter la fonctionnalité X
- Implémente la fonctionnalité X avec les tests associés.
- Corrige le bug Y lié à la fonctionnalité Z.
```

##### Conventionnel (Conventional Commits) :

```
feat(fichier.txt): Ajouter la fonctionnalité X
- Implémente la fonctionnalité X avec les tests associés.
- Corrige le bug Y lié à la fonctionnalité Z.
```

Conventional Commits est une convention populaire qui aide à automatiser la génération de changelogs et la gestion des versions.
Sa syntaxe permet de catégoriser les commits par type (feat, fix, docs, style, refactor, test, chore) et d'ajouter des scopes pour préciser les parties du code affectées. Des signes comme `!` peuvent être utilisés pour indiquer des changements majeurs.

Pour plus de détails, vous pouvez consulter le site officiel : [https://www.conventionalcommits.org/en/v1.0.0/](https://www.conventionalcommits.org/en/v1.0.0/)


### git push et git pull

#### git push

Envoie les commits locaux vers un dépôt distant.

Comme vu précédement, on a vu que les changements faits dans le dossier de travail (working directory) doivent d'abord être ajoutés à la staging area avec `git add`, puis enregistrés dans l'historique avec `git commit`. Ensuite, pour partager ces changements avec d'autres collaborateurs ou pour les sauvegarder sur un serveur distant, on utilise `git push`.

Cette commande envoie les commits de la branche locale vers la branche correspondante sur le dépôt distant (remote). Par exemple, pour pousser les changements de la branche `main` vers le dépôt distant nommé `origin`, on utilise :

```bash
git push origin main
```

Il est important de noter que `git push` ne fonctionne que si la branche distante existe déjà et que vous avez les permissions nécessaires pour y pousser. Si la branche distante n'existe pas, vous pouvez la créer en utilisant l'option `-u` lors du premier push :

```bash
git push -u origin main
```

#### git pull

Récupère les modifications depuis un dépôt distant et les fusionne avec la branche locale.

`git pull` est une commande qui combine deux actions : 

1. Elle récupère les modifications depuis un dépôt distant (fetch) 
2. Elle les fusionne avec la branche locale (merge). 

C'est une manière pratique de synchroniser votre branche locale avec les dernières modifications apportées par d'autres collaborateurs.

### git fetch vs git pull

La différence principale entre `git fetch` et `git pull` est que `git fetch` télécharge les modifications depuis le dépôt distant mais ne les fusionne pas automatiquement avec votre branche locale. Cela vous permet de revoir les modifications avant de les intégrer.

`git pull`, en revanche, effectue à la fois le téléchargement et la fusion en une seule commande. Cela peut être pratique, mais il est parfois préférable d'utiliser `git fetch` suivi de `git merge` pour avoir plus de contrôle sur le processus de fusion.

## Branches et fusion

### Création et gestion des branches (git branch, git checkout, git switch)

#### git branch

Gère les branches dans un dépôt Git.

Avec cette commande, on peut créer, lister, renommer, et supprimer des branches.

Pour créer une nouvelle branche nommée `feature-x` :

```bash
git branch feature-x
```

Si on veut supprimer cette branche : 

```bash
git branch -d feature-x
``` 

Cette commande supprime la branche si elle a été fusionnée ou si elle n'a pas de commits non fusionnés, ou qu'elle n'a pas de commits du tout. C'est la version "safe" de la suppression de branche.

La version moins "safe" est celle ci :

```bash
git branch -D feature-x
```

Celle ci, supprimera la branche, même si elle n'a pas été fusionnée ou qu'elle a des commits non fusionnés.

Pour renommer une branche, auparavant, on devait être sur une autre branche que celle qu'on voulait renommer, mais depuis git 2.23, on peut renommer la branche courante aussi.

```bash
git branch -m nouveau-nom
```

Pour lister toutes les branches, en incluant les branches distantes, on peut utiliser :

```bash
git branch -a
```

#### git checkout

Permet de naviguer entre les branches ou de restaurer des fichiers.

Pour changer de branche, on utilise :

```bash
git checkout nom-de-la-branche
```

Je l'utilise également pour récupérer un fichier supprimé par erreur, ou alors pour revenir à une version précédente d'un fichier.

```bash
git checkout README.md
```

Cette commande restaure le fichier `README.md` à son état dans le dernier commit.

#### git switch

Une commande plus récente et plus intuitive pour changer de branche.

```bash
git switch nom-de-la-branche
```

Celle ci est plus claire que `git checkout` pour le changement de branche, mais `git checkout` reste nécessaire pour d'autres opérations comme la restauration de fichiers.

<!-- ### Fusion de branches (git merge)

#### Rebase VS Merge

### Résolution des conflits de base
### Stratégies de branchement (feature branches, release branches)

## Remote repositories

### Ajout et gestion des remotes (git remote)
### Travail avec des repositories distants (GitHub, GitLab, Bitbucket) -->
